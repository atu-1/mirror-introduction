<div id="sect_title_img_3_8"></div>

<div id="sect_title_text"></div>

# 座標変換を活用する①

<div id="preface"></div>

###### [3-1節](01_Handle_Mouse_Click_Event.md) から [3-5節](05_Render_String_with_blf_Module.md) では、Blenderが提供するUIを超えて独自のUIを構築する方法について説明しました。しかしUIは基本的に2D座標で表現するため、いずれ3Dビューエリアにおいてリージョン座標から3D空間の座標、またはその逆で3D空間の座標からリージョン座標のように座標変換したいと思うときがくるとおもいます。このため本節では、Blenderが提供する座標変換を行うためのAPIを使ったアドオンを紹介したいと思います。


## 座標変換について

3Dプログラミングに馴染みのない方にとって座標変換の必要性を問われてもさっぱりわからなかったりします。筆者が初めて3Dプログラミングに挑戦した時も同じでした。しかし、3Dゲームや3Dソフト（アドオン含む）を作る立場になると、座標変換を理解して使いこなせることが必要になってきます。例えば、[3-1節](01_Handle_Mouse_Click_Event.md) で紹介したような、マウスをクリックした位置の面を削除する処理を実装するためには、スクリーン上の座標から *3Dビュー* エリアの3D空間上の座標へ変更する必要があります。幸いなことに [3-1節](01_Handle_Mouse_Click_Event.md) では、スクリーン座標を受け取って *3Dビュー* エリアの3D空間上の位置にある面を選択するAPIがBlenderから提供されていたため問題にはなりませんでした。しかし、実現したいことに対してBlenderがAPIを提供していない場合は、座標変換が必要になってきます。このため本節では、Blenderで使われている座標変換について説明します。なお、3Dプログラミングにおける座標変換については、世の中にすでにたくさんの解説記事や書籍があるため詳細な説明はしません。


座標変換を知るためにBlender本体が行っている座標変換を知っておくことは重要ですので、アドオンで座標変換する方法を説明する前に簡単に説明します。Blenderは、ユーザから与えられた頂点情報（座標や法線）などをもとに3Dポリゴンを画面に表示しますが、このときBlenderの内部では次の座標変換を行っています。

```sh
グローバル座標 = グローバル座標変換行列 × ローカル座標
リージョン座標 = ビューポート変換行列 × 射影変換行列 × ビュー変換行列 × グローバル座標
```

ローカル座標やグローバル座標については、Blenderをある程度使っている方であればすでに知っているかもしれません。ローカル座標は *エディットモード* 時のプロパティパネルの *トランスフォーム* の頂点で *ローカル* を選んだ時の *頂点* に表示されている座標値、グローバル座標は *グローバル* を選んだ時の *頂点* に表示されている座標値です。ローカル座標に対して *オブジェクトモード* 時のプロパティパネルの *トランスフォーム* で行った座標変換処理（グローバル座標変換）を適用したものがグローバル座標になります。実際にこのことを確認するために、*オブジェクトモード* でオブジェクトに対して座標変換した時のグローバル座標の値の変化を見てみましょう。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*エディットモード* であることを確認し、*3Dビュー* エリアのプロパティパネルの項目 *トランスフォーム* にある *中点* の座標値を確認します。グローバル座標を確認するため、*グローバル* ボタンが選択されていることを確認します。|![3-8節 座標変換 手順1](https://dl.dropboxusercontent.com/s/h061n17rk6i64nf/coordinate_transformation_1.png "3-8節 座標変換 手順1")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">2</div>|*オブジェクトモード* に切り替え、同じく *3Dビュー* エリアのプロパティパネルの項目 *トランスフォーム* にある *位置* の値をX方向に+1、Y方向に-1します。|![3-8節 座標変換 手順2](https://dl.dropboxusercontent.com/s/1zex048ao9qso8y/coordinate_transformation_2.png "3-8節 座標変換 手順2")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">3</div>|*エディットモード* に切り替え、*3Dビュー* エリアのプロパティパネルの項目 *トランスフォーム* にある *頂点* 値を確認すると、Xの値が+1、Yの値が-1になっていることが確認できます。|![3-8節 座標変換 手順3](https://dl.dropboxusercontent.com/s/6oj5tk3ep1h77x9/coordinate_transformation_3.png "3-8節 座標変換 手順3")|
|---|---|---|

<div id="process_sep"></div>

---


<div id="process_start_end"></div>

---


このように、ローカル座標に対して *オブジェクトモード* で行った座標変換処理（グローバル座標変換）を適用することで、グローバル座標を得られることが理解できたと思います。グローバル座標からリージョン座標への変換処理についてもBlender内のデータを使って行うことができますが、あまり直感的ではないことと本節で紹介するAPIがこの変換処理を勝手に行ってくれるので、ここでは省略します。実際のところAPIの使い方を理解し本節のサンプルを理解するためには、ローカル座標・グローバル座標・リージョン座標のみを理解できていれば問題ないです。ただし、具体的な処理の内容が気になる方もいると思うので、[3-9節](09_Use_Coordinate_Transformation_2.md) の一番最後に自力でローカル座標からリージョン座標へ変換する方法を紹介します。興味のある方は確認してみてください。


## 作成するアドオンの仕様

本節では、*3Dビュー* エリア上の3D空間座標からリージョン（2D）座標へ変換できることを示すため、次のような仕様のアドオンを作成します。

* *3Dビュー* エリアで選択されているオブジェクトについて、中心座標の移動の軌跡を画面上に表示する


## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードをテキスト・エディタに入力し、ファイル名 ```sample_3_8.py``` として保存してください。

[import](../../sample/src/chapter_03/sample_3_8.py)


## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に作成したアドオンを有効化すると、コンソールウィンドウに文字列が出力されます。

```sh
サンプル3-8: アドオン「サンプル3-8」が有効化されました。
```

<div id="sidebyside"></div>

|*3Dビュー* エリアのプロパティパネルを表示し、項目 *オブジェクトの軌跡表示* が追加されていることを確認します。|![3-8節 アドオン有効化](https://dl.dropboxusercontent.com/s/3aighvabzty5i3h/enable_add-on.png "3-8節 アドオン有効化")|
|---|---|



### アドオンの機能を使用する

有効化したアドオンの機能を使い、動作を確認します。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネルに追加された項目 *オブジェクトの軌跡表示* の *開始* ボタンをクリックします。|![3-8節 アドオンの使用 手順1](https://dl.dropboxusercontent.com/s/zin86hpouityhpu/use_add-on_1.png "3-8節 アドオンの使用 手順1")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">2</div>|*オブジェクトモード* で選択中のオブジェクトを移動すると、移動前のオブジェクトの中心座標の位置に四角形が表示されます。（一定量の軌跡を作成すると、古いものから順に消えていきます。）|![3-8節 アドオンの使用 手順2](https://dl.dropboxusercontent.com/s/lxyu2qkkrwd9bns/use_add-on_2.png "3-8節 アドオンの使用 手順2")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">3</div>|*3Dビュー* エリアのプロパティパネルの項目 *オブジェクトの軌跡表示* の *終了* ボタンをクリックすると、軌跡が表示されなくなります。|![3-8節 アドオンの使用 手順3](https://dl.dropboxusercontent.com/s/u2e109sfe5yljd0/use_add-on_3.png "3-8節 アドオンの使用 手順3")|
|---|---|---|



<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに文字列が出力されます。

```sh
サンプル3-8: アドオン「サンプル3-8」が無効化されました。
```


## ソースコードの解説

本節のサンプルでは座標変換の処理以外に ```bgl``` モジュールを利用した図形描画を行っています。```bgl``` モジュールを利用した図形描画処理については [3-4節](04_Use_API_for_OpenGL.md) を参照してください。本節では、座標変換処理に関係する処理についてのみ説明します。変数名やクラス名が異なることを除いて、[3-4節](04_Use_API_for_OpenGL.md) と同じ図形描画処理になるように記述しているため、図形描画処理について困ることはないと思います。


### アドオン内で利用するプロパティを定義する

複数のクラス間で共有するプロパティ一覧を次に示します。本節のサンプルでは、共有するプロパティが1つであるため ```bpy.types.PropertyGroup``` によるプロパティのグループ化を行っていません。

|変数|意味|
|---|---|
|```dot_running```|オブジェクトの軌跡表示中の場合は ```True```|


### bpy_extraモジュール

Blenderが提供するAPIの大半は ```bpy``` モジュールに含まれるため、ほとんどのアドオン開発者はこのモジュールを使ってアドオンを開発することが多いと思います。しかし ```bpy``` モジュールは、比較的基本的な機能しか提供しないため、使いづらいと感じることがあるかもしれません。このためBlenderは、開発者が比較的よく使うことを想定した便利なAPI群を ```bpy_extra``` モジュールとして提供しています。```bpy_extra``` モジュールを利用することで面倒な処理を1から実装することなく実現できるため、実現したい処理を実装するのが面倒だと感じたら ```bpy_extra``` モジュールでAPIとして提供されていないかを確認しましょう。

次に示すように、```bpy_extra``` モジュールは複数のサブモジュールから構成されています。アドオン開発者これらのサブモジュールの中から、利用したいAPIを含むサブモジュールをインポートします。

|サブモジュール名|概要|
|---|---|
|```anim_utils```|アニメーション関連の便利API|
|```object_utils```|オブジェクト操作関連の便利API|
|```io_utils```|インポータ/エクスポータ向けの便利APIやファイルパスに関する便利API|
|```image_utils```|画像ファイルの読込みに関する便利API|
|```keyconfig_utils```|キーコンフィグ関連の便利API|
|```mesh_utils```|メッシュ型オブジェクトに関する便利API|
|```view3d_utils```|3Dビューエリア上で座標変換を容易に行うためのAPI|


サンプルでは、座標変換を行うために ```bpy_extra``` モジュールを利用しています。座標変換を行うためのAPIは、```bpy_extra``` モジュールのサブモジュール ```view3d_utils``` に含まれているため、最初にサブモジュール ```view3d_utils``` をインポートします。

[import:"import_view3d_utils", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_8.py)



### オブジェクトの軌跡を表示する

選択中のオブジェクトの軌跡を表示するのは ```__render()``` スタティックメソッドです。```__render()``` スタティックメソッドでは、次の手順に従ってオブジェクトの軌跡を表示しています。

1. オブジェクトの位置座標を取得する
2. オブジェクトの位置座標をリージョン座標に変換する
3. 古い位置情報を削除する
4. 変換したリージョン座標に四角形を描画する


#### 1. オブジェクトの位置座標を取得する

オブジェクトの位置座標は、```bpy.data.objects``` の各要素から取得できるオブジェクトデータの ```location``` メンバ変数から取得することができます。

#### 2. オブジェクトの位置座標をリージョン座標に変換する

1で取得したオブジェクトの位置座標をリージョン座標に変換します。この座標変換を自力で実装するとなると、カメラのビュー行列などを用いて行列計算を行う必要があり、3Dプログラミングに慣れていない方はここで少し困ってしまうかもしれません。しかし、幸いなことに ```bpy_extra``` モジュールの ```view3d_utils``` サブモジュールが提供する```view3d_utils.location_3d_to_region_2d()``` 関数を利用することで、この処理を比較的簡単な方法で実現することができます。```view3d_utils.location_3d_to_region_2d()``` 関数の引数を以下に示します。リージョン情報が2つありますが、第1引数で指定するリージョン情報はこれまで説明してきたリージョン情報のことを指しますが、第2引数で指定する3Dリージョンはスペース情報に含まれる3Dリージョン情報です。3Dリージョン情報には、ビュー変換行列や射影変換行列などの情報が含まれています。

|引数|意味|
|---|---|
|第1引数|座標変換対象のリージョン情報|
|第2引数|座標変換対象の3Dリージョン情報|
|第3引数|3D空間の座標|

この ```view3d_utils.location_3d_to_region_2d()``` を使ってオブジェクトの位置座標をリージョン座標に変換する処理を次に示します。

[import:"loc_to_region", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_8.py)


3Dリージョン情報は、スペース情報の ```region_3d``` メンバ変数から取得することができます。座標変換対象のリージョンとスペースは ```__get_region_space()``` スタティックメソッドで取得します。```__get_region_space()``` スタティックメソッドは、[3-5節](05_Render_String_with_blf_Module.md) で説明した ```__get_region()``` スタティックメソッドを改良したものです。

[import:"get_region_space", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_8.py)


引数 ```area_type``` で指定されたエリア上の ```region_type``` に指定されたリージョン情報を返すことに加えて、引数 ```space_type``` に指定されたスペース情報も返します。エリア ```area``` に関するスペース情報は ```area.spaces``` に保存されているため、```s.type``` と引数 ```space_type``` が一致したものが、必要としていたスペース情報になります。サンプルでは、*3Dビュー* エリアのウィンドウリージョンを座標変換対象にしたいため、```region_type``` が ```WINDOW``` であるリージョン情報と```space_type``` が ```VIEW_3D``` であるスペース情報を取得します。


```__get_region()``` スタティックメソッドを使って取得した情報を用いて ```view3d_utils.location_3d_to_region_2d()``` 関数を呼び出します。第1引数には取得したリージョン情報を、第2引数にスペース情報の ```region_3d``` メンバ変数を、第3引数にオブジェクトデータの ```location``` メンバ変数を指定して呼び出すことで、第3引数に指定したオブジェクトの座標をリージョン座標に変換することができます。変換後のリージョン座標は ```view3d_utils.location_3d_to_region_2d()``` 関数の戻り値として取得できるため、```self.__loc_history``` メンバ変数に保存します。```self.__loc_history``` の末尾に追加することで先頭が最も古い位置情報、末尾が最新の位置情報となります。

#### 3. 古い位置情報を削除する

位置情報の履歴は一定量を超えた時に削除しないと、画面が四角形で埋め尽くされてしまいます。このため、次の処理により位置情報の履歴数が100以上になった時に最も古い位置情報（```self.__loc_history``` の先頭の要素）を削除します。

[import:"delete_oldest_loc", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_8.py)

#### 4. 変換したリージョン座標に四角形を描画する

最後に、変換したリージョン座標に四角形を描画します。四角形の描画は ```bgl``` モジュールを使い、```self.__loc_history``` に保存されたすべての要素について [3-4節](04_Use_API_for_OpenGL.md) で説明した方法で描画します。描画処理については、新しいことは行っていないので具体的な処理の説明は省略します。

[import:"render_rect", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_8.py)


## まとめ

本節では、*3Dビュー* エリア上の3D空間座標からリージョン座標へ変換するアドオンのサンプルを紹介しました。```bpy_extra``` モジュールの ```view3d_utils``` サブモジュールを使用することにより、自前で座標変換を行う必要がなくなりました。このように ```bpy_extra``` モジュールには、自前で行うと面倒な処理を簡単な手順で実現できるAPIが提供されています。```bpy_extra``` モジュールが提供するAPIの数は少ないですが、座標変換に限らず便利なAPIを提供しているため、一度目を通しておくと良いと思います。

本節では、*3Dビュー* エリア上の3D空間座標からリージョン座標へ変換しましたが、[3-9節](09_Use_Coordinate_Transformation_2.md) ではその逆の座標変換である、リージョン座標から *3Dビュー* エリア上の3D空間座標へ変換する方法を説明します。


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* Blenderは3Dポリゴンを画面に表示するまでに、グローバル座標変換→ビュー変換→射影変換→ビューポート変換を行なってローカル座標からリージョン座標へ座標変換する
* ```bpy_extra``` モジュールは、```bpy``` モジュールだけで処理を実装すると面倒な処理を、開発者がAPI呼び出しだけで簡単に実現できるようにしたAPIの集まりである
* ```bpy_extra``` モジュールのサブモジュールである ```view3d_utils``` サブモジュールは、*3Dビュー* エリア上で座標変換を行うためのAPIを提供する
